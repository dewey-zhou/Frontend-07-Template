# 总结
## Trie 字典树

用来统计大量字符串，可以找到出现最多次的字符串或最少 或者你指定出现次数  
定义：又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

主要注意点：  
1.关于this.root，node为什么数据是连通的，需要理解栈内存和堆内存的问题，this.root和node 指向的都是同一地址的对象
2.递归问题，通过递归来进行层层遍历

## KMP算法

代码逻辑简单，主要是理解它的原理，而原理中最重要的就是搞清table（PMT部分匹配表）

PMT：就是看对应着这个字符串的第i个位置的前缀是否和整个字符串开头一样，一样的就标识一样部分的长度，不一样则为0 ，然后字符串每个位置都标识出来，这样等进行匹配时，匹配失败则直接跳到table标识的那个位置继续匹配就行，从而实现KMP算法

## Wildcard算法

介绍：*：可充当长度大于等于0的任一字符串；？：可充当任一字符串  
```javasScript
ab*c?d*abc*a?d
```  
算法分析： 整个字符串可以拆分成三部分：第一个\*号之前的字符串；第一个\*号之后和最后一个\*号之前；最后一个\*号之后

1.第一个\*号之前，进行遍历匹配
2.第一个\*号之后和最后一个\*号之前，将其以\*号拆分成字符串再进行匹配（这里可以用正则匹配也可以用kmp算法进行匹配）
3.最后一个\*号之后，进行遍历匹配 ，这里要注意 由于\*号是充当任意长度的字符串，所以需要匹配的是目标字符的最后几个字符是否和模板字符的最好几个字符是否相等  

正则匹配的话 利用exec()方法来进行截取并比较  
kmp的话 则只需要注意kmp返回匹配到的最末尾的位置 然后截取s 再进行匹配 否则 会重复匹配导致匹配出错

